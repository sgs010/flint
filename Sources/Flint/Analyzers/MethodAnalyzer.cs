using System.Diagnostics.CodeAnalysis;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using Flint.Vm;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Cil = Flint.Vm.Cil;
using Match = Flint.Vm.Match;

namespace Flint.Analyzers
{
	internal class MethodAnalyzer
	{
		#region Interface
		public static IEnumerable<MethodDefinition> GetMethods(ModuleDefinition asm, string className = null, string methodName = null)
		{
			foreach (var type in asm.Types)
			{
				if (className != null && type.Name != className)
					continue;

				foreach (var mtd in type.Methods)
				{
					if (methodName != null && mtd.Name != methodName)
						continue;

					yield return mtd;
				}
			}
		}

		public static List<Ast> Eval(MethodDefinition method)
		{
			var actualMethod = UnwrapAsyncMethod(method);

			if (actualMethod.HasBody == false)
				return []; // this is an abstract method, nothing to evaluate

			// eval method body
			var expressions = CilMachine.Run(actualMethod);

			// eval lambdas
			var last = expressions.Count();
			for (var i = 0; i < last; ++i)
			{
				var expr = expressions[i];
				var (captures, ok) = expr.Match(
					new Match.Ftn(),
					true);
				if (ok == false)
					continue;

				foreach (Cil.Ftn ftn in captures.Values)
				{
					var lambdaExpressions = Eval(ftn.Method);
					expressions.AddRange(lambdaExpressions);
				}
			}
			return expressions;
		}

		public static List<Ast> EvalRecursive(AssemblyDefinition asm, MethodDefinition method)
		{
			var methodMap = new Dictionary<MethodDefinition, List<Ast>>();
			EvalRecursive(asm, method, methodMap);
			return methodMap.Values.SelectMany(x => x).ToList();
		}

		public static void CollectLambdaExpressions(IEnumerable<Ast> methodExpressions, List<Ast> lambdaExpressions)
		{
			foreach (var expr in methodExpressions)
			{
				var (captures, ok) = expr.Match(
					new Match.Ftn(), // Ftn is ldftn IL instruction, lambdas are translated into this
					true);
				if (ok == false)
					continue;

				foreach (Cil.Ftn ftn in captures.Values)
				{
					var lambdaMethod = UnwrapAsyncMethod(ftn.Method);
					var lambda = CilMachine.Run(lambdaMethod);
					lambdaExpressions.AddRange(lambda);
					CollectLambdaExpressions(lambda, lambdaExpressions);
				}
			}
		}

		public static void PrettyPrintMethod(StringBuilder sb, MethodDefinition mtd, SequencePoint sp)
		{
			sb.Append(mtd.DeclaringType.Namespace);
			sb.Append('.');
			sb.Append(mtd.DeclaringType.Name);
			sb.Append('.');
			sb.Append(mtd.Name);

			if (sp != null)
			{
				sb.Append(" line ");
				sb.Append(sp.StartLine);
			}
		}
		#endregion

		#region Implementation
		class ParameterTypeEqualityComparer : IEqualityComparer<ParameterDefinition>
		{
			public static ParameterTypeEqualityComparer Instance = new();

			public bool Equals(ParameterDefinition x, ParameterDefinition y)
			{
				return x.ParameterType.Equals(y.ParameterType);
			}

			public int GetHashCode(ParameterDefinition obj)
			{
				return obj.ParameterType.GetHashCode();
			}
		}

		private static MethodDefinition UnwrapAsyncMethod(MethodDefinition method)
		{
			// check if method is async and return actual implementation
			MethodDefinition asyncMethod = null;
			if (method.HasCustomAttributes)
			{
				var asyncAttr = method.CustomAttributes.FirstOrDefault(x => x.AttributeType.FullName == "System.Runtime.CompilerServices.AsyncStateMachineAttribute");
				if (asyncAttr != null)
				{
					var stmType = (TypeDefinition)asyncAttr.ConstructorArguments[0].Value;
					asyncMethod = stmType.Methods.First(x => x.Name == "MoveNext");
				}
			}
			return asyncMethod ?? method;
		}

		private static bool IsAutoGenerated(MethodDefinition method)
		{
			if (method.HasCustomAttributes == false)
				return false;

			var attr = method.CustomAttributes.FirstOrDefault(x => x.AttributeType.FullName == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
			if (attr == null)
				return false;

			return true;
		}

		private static bool HaveSameSignatures(MethodDefinition m1, MethodDefinition m2)
		{
			return m1.Name.Equals(m2.Name)
				&& m1.ReturnType.Equals(m2.ReturnType)
				&& m1.Parameters.SequenceEqual(m2.Parameters, ParameterTypeEqualityComparer.Instance);
		}

		private static void EvalRecursive(AssemblyDefinition asm, MethodDefinition method, Dictionary<MethodDefinition, List<Ast>> methodMap)
		{
			if (methodMap.ContainsKey(method))
				return; // already evaluated

			List<Ast> methodExpressions = null;
			if (method.HasBody)
			{
				// eval method
				methodExpressions = Eval(method);
			}
			else if (method.DeclaringType.IsInterface)
			{
				// try to eval interface implementations
				if (asm.InterfaceImplementations.TryGetValue(method.DeclaringType, out var implTypes))
				{
					methodExpressions = [];
					var implMethods = implTypes.SelectMany(x => x.Methods.Where(m => HaveSameSignatures(method, m)));
					foreach (var impl in implMethods)
					{
						var implExpressions = Eval(impl);
						methodExpressions.AddRange(implExpressions);
					}
				}
			}
			if (methodExpressions == null || methodExpressions.Count == 0)
				return; // nothing to evaluate

			methodMap.Add(method, methodExpressions);
			foreach (var call in methodExpressions.OfCall())
			{
				if (call.Method.Module != asm.Module)
					continue; // do not evaluate external modules

				var callMethod = call.Method.Resolve();
				if (IsAutoGenerated(callMethod))
					continue; // do not evaluate get/set autogenerated methods

				EvalRecursive(asm, callMethod, methodMap);
			}
		}
		#endregion
	}
}
