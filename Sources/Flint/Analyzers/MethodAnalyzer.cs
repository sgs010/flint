using Flint.Vm;
using Mono.Cecil;
using Cil = Flint.Vm.Cil;
using Match = Flint.Vm.Match;

namespace Flint.Analyzers
{
	internal class MethodAnalyzer
	{
		#region Interface
		public static IEnumerable<MethodDefinition> GetMethods(ModuleDefinition asm, string className = null, string methodName = null)
		{
			foreach (var type in asm.Types)
			{
				if (className != null && type.Name != className)
					continue;

				foreach (var mtd in type.Methods)
				{
					if (methodName != null && mtd.Name != methodName)
						continue;

					yield return mtd;
				}
			}
		}

		public static List<Ast> Eval(MethodDefinition method)
		{
			var actualMethod = UnwrapAsyncMethod(method);

			if (actualMethod.HasBody == false)
				return []; // this is an abstract method, nothing to evaluate

			// eval method body
			var expressions = CilMachine.Run(actualMethod);

			// eval lambdas
			var last = expressions.Count();
			for (var i = 0; i < last; ++i)
			{
				var expr = expressions[i];
				var (captures, ok) = expr.Match(
					new Match.Ftn(),
					true);
				if (ok == false)
					continue;

				foreach (Cil.Ftn ftn in captures.Values)
				{
					var lambdaExpressions = Eval(ftn.Method);
					expressions.AddRange(lambdaExpressions);
				}
			}
			return expressions;
		}

		public static List<Ast> EvalRecursive(MethodDefinition method)
		{
			var methodMap = new Dictionary<MethodDefinition, List<Ast>>();
			EvalRecursive(method.Module, method, methodMap);
			return methodMap.Values.SelectMany(x => x).ToList();
		}

		public static void CollectLambdaExpressions(IEnumerable<Ast> methodExpressions, List<Ast> lambdaExpressions)
		{
			foreach (var expr in methodExpressions)
			{
				var (captures, ok) = expr.Match(
					new Match.Ftn(), // Ftn is ldftn IL instruction, lambdas are translated into this
					true);
				if (ok == false)
					continue;

				foreach (Cil.Ftn ftn in captures.Values)
				{
					var lambdaMethod = UnwrapAsyncMethod(ftn.Method);
					var lambda = CilMachine.Run(lambdaMethod);
					lambdaExpressions.AddRange(lambda);
					CollectLambdaExpressions(lambda, lambdaExpressions);
				}
			}
		}
		#endregion

		#region Implementation
		private static MethodDefinition UnwrapAsyncMethod(MethodDefinition method)
		{
			// check if method is async and return actual implementation
			MethodDefinition asyncMethod = null;
			if (method.HasCustomAttributes)
			{
				var asyncAttr = method.CustomAttributes.FirstOrDefault(x => x.AttributeType.FullName == "System.Runtime.CompilerServices.AsyncStateMachineAttribute");
				if (asyncAttr != null)
				{
					var stmType = (TypeDefinition)asyncAttr.ConstructorArguments[0].Value;
					asyncMethod = stmType.Methods.First(x => x.Name == "MoveNext");
				}
			}
			return asyncMethod ?? method;
		}

		private static bool IsAutoGenerated(MethodDefinition method)
		{
			if (method.HasCustomAttributes == false)
				return false;

			var attr = method.CustomAttributes.FirstOrDefault(x => x.AttributeType.FullName == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
			if (attr == null)
				return false;

			return true;
		}

		private static void EvalRecursive(ModuleReference module, MethodDefinition method, Dictionary<MethodDefinition, List<Ast>> methodMap)
		{
			if (methodMap.ContainsKey(method))
				return;

			var methodExpressions = Eval(method);
			methodMap.Add(method, methodExpressions);

			foreach (var call in methodExpressions.OfType<Cil.Call>())
			{
				if (call.Method.Module != module)
					continue; // do not evaluate external modules

				var callMethod = call.Method.Resolve();
				if (IsAutoGenerated(callMethod))
					continue; // do not evaluate get/set autogenerated methods

				EvalRecursive(module, callMethod, methodMap);
			}
		}
		#endregion
	}
}
