using System.Collections.Immutable;
using System.Text;
using Flint.Common;
using Flint.Vm;
using Flint.Vm.Cil;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Match = Flint.Vm.Match;

namespace Flint.Analyzers
{
	internal class MethodAnalyzer
	{
		#region Interface
		public static IEnumerable<MethodDefinition> GetMethods(AssemblyDefinition asm, string className = null, string methodName = null)
		{
			foreach (var method in asm.MethodExpressions.Keys)
			{
				if (methodName != null && method.Name != methodName)
					continue;
				if (className != null && method.DeclaringType.Name != className)
					continue;
				yield return method;
			}
		}

		public static List<Ast> EvalRaw(MethodDefinition method)
		{
			var actualMethod = method.UnwrapAsyncMethod();

			if (actualMethod.HasBody == false)
				return []; // this is an abstract method, nothing to evaluate

			// eval method body
			var expressions = CilMachine.Run(actualMethod);

			// eval lambdas
			var last = expressions.Count;
			for (var i = 0; i < last; ++i)
			{
				var expr = expressions[i];
				var (captures, ok) = expr.Match(
					new Match.Ftn(),
					true);
				if (ok == false)
					continue;

				foreach (var ftn in captures.Values.Cast<Ftn>())
				{
					var lambdaExpressions = EvalRaw(ftn.Method);
					expressions.AddRange(lambdaExpressions);
				}
			}
			return expressions;
		}

		public static ImmutableArray<Ast> Eval(AssemblyDefinition asm, MethodDefinition method)
		{
			if (asm.MethodExpressions.TryGetValue(method, out var expr))
				return expr;
			return [];
		}

		public static List<Ast> EvalRecursive(AssemblyDefinition asm, MethodDefinition method)
		{
			var methodMap = new Dictionary<MethodDefinition, List<Ast>>();
			EvalRecursive(asm, method, methodMap);
			return methodMap.Values.SelectMany(x => x).ToList();
		}

		public static void CollectLambdaExpressions(IEnumerable<Ast> methodExpressions, List<Ast> lambdaExpressions)
		{
			foreach (var expr in methodExpressions)
			{
				var (captures, ok) = expr.Match(
					new Match.Ftn(), // Ftn is ldftn IL instruction, lambdas are translated into this
					true);
				if (ok == false)
					continue;

				foreach (var ftn in captures.Values.Cast<Ftn>())
				{
					var lambdaMethod = ftn.Method.UnwrapAsyncMethod();
					var lambda = CilMachine.Run(lambdaMethod);
					lambdaExpressions.AddRange(lambda);
					CollectLambdaExpressions(lambda, lambdaExpressions);
				}
			}
		}

		public static void PrettyPrintMethod(StringBuilder sb, MethodDefinition method, SequencePoint sp)
		{
			sb.Append(method.DeclaringType.Namespace);
			sb.Append('.');
			sb.Append(method.DeclaringType.Name);
			sb.Append('.');
			sb.Append(method.Name);

			if (sp != null)
			{
				sb.Append(" line ");
				sb.Append(sp.StartLine);
			}
		}
		#endregion

		#region Implementation
		private static void EvalRecursive(AssemblyDefinition asm, MethodDefinition method, Dictionary<MethodDefinition, List<Ast>> methodMap)
		{
			if (methodMap.ContainsKey(method))
				return; // already evaluated

			List<Ast> methodExpressions = [];
			if (method.HasBody)
			{
				// eval method
				var expr = Eval(asm, method);
				methodExpressions.AddRange(expr);
			}
			else if (method.DeclaringType.IsInterface)
			{
				// try to eval interface implementations
				if (asm.InterfaceImplementations.TryGetValue(method.DeclaringType, out var implTypes))
				{
					var implMethods = implTypes.SelectMany(x => x.Methods.Where(m => m.SignatureEquals(method)));
					foreach (var impl in implMethods)
					{
						var expr = Eval(asm, impl);
						methodExpressions.AddRange(expr);
					}
				}
			}
			if (methodExpressions.Count == 0)
				return; // nothing to evaluate

			methodMap.Add(method, methodExpressions);
			foreach (var call in methodExpressions.OfCall())
			{
				if (call.Method.Module != asm.Module)
					continue; // do not evaluate external modules

				var callMethod = call.Method.Resolve();
				if (callMethod.IsCompilerGenerated())
					continue; // do not evaluate get/set autogenerated methods

				EvalRecursive(asm, callMethod, methodMap);
			}
		}
		#endregion
	}
}
